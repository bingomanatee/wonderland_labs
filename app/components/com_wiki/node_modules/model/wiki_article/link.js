var NE = require('nuby-express');
var Gate = NE.deps.support.nakamura_gate;
var _DEBUG = false;
var _ = require('underscore');

var wiki_links = require('./../../parsers/wiki_links');
var wiki_link_parts = require('./../../parsers/link_parts');

function _unique_links(links) {
    var link_hash = _.reduce(links, function (lh, link) {
        if (!lh[link.scope]) {
            lh[link.scope] = {};
        }

        lh[link.scope][link.name] = link;

        return lh;
    }, {})

    var out = [];

    _.each(link_hash, function (links) {
        out = out.concat(_.values(links));
    });

    return out;
}

/**
 * This function finds all the articles that are linked from this article.
 * Note there may be some missing articles, if the article has stub links.
 *
 * @param link_parts
 * @private
 */

function _link_out(article, link_parts, cb) {
    var self = this;
    var gate2 = Gate.create();

    link_parts.forEach(function (link) {
        //   if (_DEBUG) console.log('linking  %s', util.inspect(link));
        var latch = gate2.latch();

        self.article(link.scope, link.name, function (err, linked_article) {
            if (!linked_article) {
                return;
            }

            self.get_linked_to(link, function(err, docs){
                linked_article.linked_from = _.map(docs, function(doc){
                    return {name: doc.name, scope: doc.scope, title: doc.title};
                })


                // linked_article.linked_from = _unique_links(linked_article.linked_from);
                linked_article.markModified('linked_from');
                linked_article.save(latch);
            })
        });
    });

    gate2.await(function (err, res) {
        if (_DEBUG) console.log('DONE linking articles from %s, :%s', article.name, util.inspect(res));
        if (cb) {
            cb();
        }
    });
}

/**
 *
 * updates article's link_to collection
 * and article's linked_from collection
 *
 * @private
 */

function _link_in(article, cb) {
    var self = this;

    if (_DEBUG) console.log('re-linking targets from article %s in scope %s', article.name, article.scope);

    var links = wiki_links(article.content + article.summary);
    var link_parts = wiki_link_parts(links, article);

    if (_DEBUG) console.log('links: %s', util.inspect(link_parts));

    if (article.markModified) { // article is an actual document

        _.each(link_parts, function (part) {
            _.defaults(part, {scope:article.scope});
        });
        article.link_to = link_parts;
        article.markModified('link_to');

        this.get_linked_to(article,
            function (err, in_links) {
                article.linked_from = _.map(in_links, function (il) {
                    return {name:il.name, title:il.title, scope:il.scope}
                })
                article.markModified('linked_from');
                article.save(function (err, art) {
                    _.bind(_link_out, self)(article, link_parts, cb);
                });
            })

    } else {
        _.bind(_link_out, self)(article, link_parts, cb);
    }
}

/**
 * Removing references in an article to input links from another article
 *
 * @param doc|Object article A wiki article you awnt to clean; does not need to be a document
 * @param doc old_from An artical that may (once?) have (had) a reference to article
 * @param cb: function
 * @private
 */
function _unlink_from(article, old_from, cb) {

    if (article.linked_from.length) {
        article.linked_from = _.reject(article.linked_from, function (item) {
            return (item.scope == old_from.scope) && (item.name == old_from.name);
        })

        article.markModified('linked_from');
        article.save(cb);
    }
}


module.exports = function (model) {

    model.get_linked_from = function (article, cb) {
        this.active().where('linked_from').elemMatch({name:article.name, scope:article.scope}).exec(cb);
    }

    model.get_linked_to = function (article, cb) {
        this.active().where('link_to').elemMatch({name:article.name, scope:article.scope})
            .select('name title scope').exec(cb);

    }

    return _.bind(function (article, cb) {
            if (!cb){
                throw new Error('no callback to link');
            }
            var callback = function(){
                if (tb){
                    console.log(' link took too long');
                    clearTimeout(tb);
                    tb = false;
                }
                cb();
            }

            var tb = setTimeout(callback, 5000);

            var self = this;

            var gate = Gate.create();

            // remove old links

            self.get_linked_from(article,
                function (err, docs) {
                    docs.forEach(function (doc) {
                        _unlink_from(doc, article, gate.latch());
                    })

                    gate.await(function () {
                        _.bind(_link_in, model)(article, callback);
                    });
                }
            )
        }
        , model);
}