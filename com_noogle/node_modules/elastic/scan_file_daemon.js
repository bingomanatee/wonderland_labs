var NE = require('nuby-express');
var fs = require('fs');
var path = require('path');
var util = require('util');

var file_model_factory = require('./../../resources/models/noogle_file_model');
var stl = require('./../stream_to_lines');
var NE = require('nuby-express');
var elastic = require('./index');
var release_notes = require('./../release_notes');

var con = 'mongodb://localhost/ne_bootstrap'; // @todo: use frame config
NE.deps.mongoose.connect(con);
var _DEBUG = true;

var job_pid = null;

/** ************** NOTE *************
 this job should be started by the scan_files module.
 otherwise it will just scan one file and return.
 */
process.stdout.write('scan file daemon ......');
var file_model = file_model_factory();

file_model.find_one({deleted:false, state:'not started'}, function (err, file) {
    process.stdout.write(( err ? err.message : 'data retrived') + '. ', 'utf8');
    if (file) {
        process.stdout.write(util.format('scanning file %s of domain %s ', file.file, file.domain));
        file.state = 'started';
        file.save(function (err, result) {
//@TODO: error check
            file_model.read_stream(file, function (err, stream) {
                if (err) {
                    file.state = 'error:' + err.message;
                    file.save(function (err, res) {
                        process.stdout.write('file not found');
                        NE.deps.mongoose.disconnect();
                    })
                } else {
                    console.log('_read_lines_of_file with stream for %s', file_model.file_path(file));

                    function _err_cb(err) {
                        if (err) {
                            if (_DEBUG)  console.log('err from _read_lines_of_file: %s', util.inspect(err));
                            file.result = 'err: ', +err.message;
                            file.status = 'error';
                            file.save(function () {
                                try {
                                    process.stderr.write(err.message);
                                    NE.deps.mongoose.disconnect();
                                    process.stdout.write('finished file ' + file_record.file);

                                } catch (e) {
                                    process.stderr.write(e.message);
                                    process.stdout.write('finished file ' + file_record.file);
                                }
                            })
                        }
                    }

                    function _on_done() {
                        if (_DEBUG) process.stdout.write('done - saving file...');
                        file.parsed = true;
                        file.state = 'parsed';
                        var timeout = setTimeout(function () {
                            process.stderr.write('error writing file ' + file.file + ' took too long');

                            var t2 = setTimeout(function(){
                                process.stdout.write('finished file ' + file_record.file);
                                t2 = false;
                            }, 6000);
                            NE.deps.mongoose.disconnect(function () {
                                if (t2){
                                    clearTimeout(t2);
                                    t2 = null;
                                    process.stdout.write('finished file (forced) ' + file.file);
                                }
                            });
                        }, 6000); // allowing six seconds to save
                        file.save(function (err, file_record) {
                            if (timeout) {
                                clearTimeout(timeout);
                                timeout = null;
                                NE.deps.mongoose.disconnect(function () {
                                    process.stdout.write('finished file ' + file_record.file);
                                });
                            }
                        })

                    }

                    _read_lines_of_file(stream, file, _err_cb, _on_done);
                }
            });
        })
    } else {
        process.stdout.write('all files scanned');
        NE.deps.mongoose.disconnect();
    }

})

function _t(message) {
    var re = /([\d]+)-([\d]+)-([\d]+)/;

    if (re.test(message.date)) {
        var dd = re.exec(message.date);
        var d = new Date(dd[1], dd[2], dd[3], 0, message.minutes);
        return d.getTime();
    } else {
        return 0;
    }
}

function _m(t) {
    var td = t.split(':');
    return 68 * parseInt(td[0]) + parseInt(td[1]);
}

function _read_lines_of_file(stream, file, err_cb, done_cb) {
    var regex = file_model.line_regex(file);
    console.log('reading lines of %s', file.file);
    var ln = 0;

    function on_line(content, line) {
        ++ln;
        if (regex.test(content)) {
            console.log('good line: %s', content);
            var match = regex.exec(content);
            var message = {
                minutes:_m(match[1]),
                username:match[2],
                line:line,
                message:match[3],
                date:file.file.split('.')[0]
            }
            message.time = _t(message);
            message.relevance = release_notes.relevance(message.time);

            elastic.message(message, function (err, res) {
                if (_DEBUG) console.log('wrote line to ELASTIC: %s, response: %s, err: %s', util.inspect(message), res, err ? err.message : '');
            })
        }
    }

    stl(stream, on_line, err_cb, done_cb);
}