var stream_to_lines = require('./../stream_to_lines');
var fs = require('fs');
var child_process = require('child_process');
var path = require('path');
var util = require('util');
var _ = require('underscore');

var RELEASE_NOTES_PATH = path.resolve(__dirname, 'release_notes.txt');
var RELEASE_RE = /^(.*), Version (.+) \((.*)\)(, (.*))?$/
var BULLET_RE = /^\* ([\w]*): (.*)$/

var _DEBUG = false;
var _DEBUG_REL = true;

var _summary = null;

function _i(n) {
    n = n.replace(/^0/, '');
    if (n == '') return 0
    return parseInt(n);
}

function _vv(numbers) {
    var value = 10 * numbers.major;
    if (numbers.minor) {
        value += numbers.minor / 2;
    }
    if (numbers.dot) {
        value += numbers.dot / 20;
    }
    return value;
}

module.exports = {

    parse_vesion:function (v) {
        if (!_.isString(v)) {
            throw new Error('parse_version requires string');
        }
        var v_data = {
            major:0,
            minor:0,
            dot:0,
            milestone:''
        }
        var vd = v.split('.');
        if (vd.length) {
            v_data.major = _i(vd.shift());
        }
        if (vd.length) {
            v_data.minor = _i(vd.shift());
        }
        if (vd.length) {
            v_data.dot = _i(vd.shift());
        }
        if (vd.length) {
            v_data.milestone = vd.join('.');
        }

        return v_data;
    },

    parse_date:function (date_string) {
        if (!_.isString(date_string)) {
            throw new Error('bad input for parse_date: ' + util.inspect(date_string));
        }
        var parts = date_string.split('.');
        if (_DEBUG) console.log('date_parts: %s', util.inspect(parts));

        return {
            year:_i(parts[0]),
            month:_i(parts[1]),
            date:_i(parts[2])
        };
    },

    line_data:function (line) {

        if (_DEBUG) {
            console.log('testing %s', line);
        }
        var j = false;

        if (RELEASE_RE.test(line)) {
            var r = RELEASE_RE.exec(line);
            if (_DEBUG) {
                console.log('line regex output: %s', util.inspect(r));
            }
            var data = {
                CLASS:'release',
                date:(r[1]),
                version:r[2],
                version_state:r[3],
                hash:r[4]
            };

            _.extend(data, module.exports.parse_date(data.date));

            data.version_numbers = module.exports.parse_vesion(data.version);
            return data;

        } else if (BULLET_RE.test(line)) {
            var r = BULLET_RE.exec(line);
            return {
                CLASS:'bullet',
                subject:r[1],
                notes:r[2]
            }


        } else {
            return false;
        }
    },

    read_config:function (callback) {

        var releases = {releases:[]};
        var release = false;

        function _on_done() {
            callback(null, releases);
        }

        function _on_err(err) {
            callback(err);
        }

        function _on_line(line) {
            var data = module.exports.line_data(line);
            if (data) {
                switch (data.CLASS) {
                    case 'release':
                        delete data.CLASS;
                        if (release) {
                            releases.releases.push(release);
                        }
                        ;
                        release = {
                            release:data,
                            notes:[]
                        }
                        break;

                    case 'bullet': // note - assuming releases come before bullets;
                        if (!release) {
                            throw new Error('bullet %s found before a release', line);
                        }
                        delete data.CLASS;
                        release.notes.push(data);
                        break;

                    default:
                    // don't care about blank lines
                }
            }
        }

        stream_to_lines(RELEASE_NOTES_PATH, _on_line, _on_err, _on_done);


    },

    summarize:function () {
        if (!_summary) {
            var release_notes = fs.readFileSync(path.resolve(__dirname, 'release_notes.json'), 'utf8');
            var j = JSON.parse(release_notes);
            //    console.log('releases: %s', release_notes.substr(0, 300));

            _summary = _.map(j.releases, function (data, i) {
                var release = data.release;
                var time_date = new Date(release.year, release.month, release.date);
                var time = time_date.getTime();
                //  console.log('summarizing release %s', util.inspect(release));
                return {
                    version:release.version,
                    version_value:_vv(release.version_numbers),
                    version_numbers:_.clone(release.version_numbers),
                    release_numer:i + 1,
                    date:{
                        year:release.year,
                        month:release.month,
                        date:release.date
                    },
                    time:time
                }


            });
            _summary = _.sortBy(_summary, function (s) {
                return s.time * -1;
            })
        }
        return _.map(_summary, _.clone);
    },

    relevance:function (time) {
        var s = module.exports.summarize();

        if (_DEBUG_REL) console.log(' ----- time: %s', time);
        if (_.isString(time)){
            var date_parts = time.split('-');
            if (_DEBUG_REL) console.log(' ----- date_parts: %s', util.inspect(date_parts));
            var date = new Date(date_parts[0], date_parts[1], date_parts[2]);
            if (_DEBUG_REL) console.log('date from %s: %s(%s)', time, date.toString(), date.getTime());
            time = date.getTime();
            if (_DEBUG_REL) console.log(' ----- resulting time: %s', time);
        }
        if (_DEBUG_REL && (!sum_shown)) {
            console.log('summary: %s', util.inspect(s));
            sum_shown = true;
        }

        var version = _.reduce(s, function(last, version){
            if (last){
                if (version.time <= time){ // version is viable not after time

                    if ((last.time > time) // current candidate is invalid
                        || (last.time < version.time)//current candidate is valid but version is more current
                        ){
                        return version;
                    } else {
                        return last;
                    }
                }
            } else {
                return version;
            }
        }, null);

        if (_DEBUG_REL) console.log('using version %s', JSON.stringify(version));

        return version.version_value;
    }
}

var sum_shown = false